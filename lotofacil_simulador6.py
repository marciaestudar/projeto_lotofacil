# -*- coding: utf-8 -*-
"""lotofacil_simulador6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H8b0_3JxT3t1BVK5orrqJlO8nGEg8Wb1
"""

import streamlit as st
import random
import pandas as pd
import collections
from datetime import datetime
import os # Para verificar a exist√™ncia de arquivos

# --- CONFIGURA√á√ïES DA P√ÅGINA ---
st.set_page_config(
    page_title="Simulador e Estat√≠sticas Lotof√°cil",
    page_icon="üé≤",
    layout="wide" # Layout mais amplo para acomodar mais conte√∫do
)

st.title("üé≤ Simulador e Estat√≠sticas da Lotof√°cil")
st.write("Gere sorteios, veja seu hist√≥rico e compare com os dados oficiais da Caixa.")

# --- Nomes dos arquivos de dados ---
ARQUIVO_HISTORICO_OFICIAL = 'Lotofacil.csv'
ARQUIVO_TABELA_PRECO = 'Tabela_Preco.csv'

# --- Inicializa√ß√£o do Estado da Sess√£o ---
# Hist√≥rico de Sorteios Simulados
if 'historico_sorteios_simulados' not in st.session_state:
    st.session_state.historico_sorteios_simulados = []

# Vari√°vel para armazenar o √∫ltimo sorteio gerado (simulado) antes de ir para o hist√≥rico
if 'ultimo_sorteio_gerado_simulado' not in st.session_state:
    st.session_state.ultimo_sorteio_gerado_simulado = None

# --- Fun√ß√µes Comuns ---
def carregar_dados_oficiais():
    """Carrega o hist√≥rico de sorteios oficiais da Lotof√°cil de um CSV."""
    if os.path.exists(ARQUIVO_HISTORICO_OFICIAL):
        try:
            df = pd.read_csv(ARQUIVO_HISTORICO_OFICIAL, sep=',')
            # Tenta converter a coluna 'Data Sorteio' para datetime
            df['Data Sorteio'] = pd.to_datetime(df['Data Sorteio'], errors='coerce')
            df.dropna(subset=['Data Sorteio'], inplace=True) # Remove linhas com data inv√°lida
            return df
        except Exception as e:
            st.error(f"Erro ao carregar o arquivo {ARQUIVO_HISTORICO_OFICIAL}: {e}")
            return pd.DataFrame() # Retorna DataFrame vazio em caso de erro
    return pd.DataFrame()

def salvar_novo_sorteio_oficial(novo_sorteio_df):
    """Salva um novo sorteio oficial no arquivo CSV."""
    df_existente = carregar_dados_oficiais()
    df_atualizado = pd.concat([df_existente, novo_sorteio_df], ignore_index=True)
    df_atualizado.to_csv(ARQUIVO_HISTORICO_OFICIAL, index=False, sep=',')
    st.success(f"Novo concurso {novo_sorteio_df['Concurso'].iloc[0]} adicionado com sucesso!")
    st.session_state._dados_oficiais_cache = None # Limpa cache para recarregar
    st.rerun()

def carregar_tabela_precos():
    """Carrega a tabela de pre√ßos do jogo de um CSV."""
    if os.path.exists(ARQUIVO_TABELA_PRECO):
        try:
            df = pd.read_csv(ARQUIVO_TABELA_PRECO, sep=',')
            return df
        except Exception as e:
            st.error(f"Erro ao carregar o arquivo {ARQUIVO_TABELA_PRECO}: {e}")
            return pd.DataFrame()
    return pd.DataFrame()

# Caching para evitar recarregar dados oficiais a cada intera√ß√£o
@st.cache_data(ttl=3600) # Cache por 1 hora
def get_dados_oficiais_cached():
    return carregar_dados_oficiais()

@st.cache_data(ttl=3600) # Cache por 1 hora
def get_tabela_precos_cached():
    return carregar_tabela_precos()

# --- Fun√ß√µes do Simulador ---

def gerar_sorteio_lotofacil():
    """Gera 15 n√∫meros √∫nicos entre 1 e 25."""
    sorteio = random.sample(range(1, 26), 15)
    sorteio.sort()
    return sorteio

def adicionar_sorteio_simulado_ao_historico(sorteio_para_adicionar):
    """
    Adiciona um sorteio ao hist√≥rico de sorteios simulados,
    mas apenas se j√° houver um sorteio 'anterior' no ultimo_sorteio_gerado_simulado.
    """
    if st.session_state.ultimo_sorteio_gerado_simulado is not None:
        data_anterior = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        st.session_state.historico_sorteios_simulados.append({
            'data': data_anterior,
            'sorteio': st.session_state.ultimo_sorteio_gerado_simulado
        })
    st.session_state.ultimo_sorteio_gerado_simulado = sorteio_para_adicionar

def calcular_estatisticas_geral(df_sorteios, tipo_estatistica):
    """Calcula a frequ√™ncia de cada n√∫mero em um DataFrame de sorteios."""
    if df_sorteios.empty:
        return pd.DataFrame({'N√∫mero': [], 'Frequ√™ncia': []})

    # Coleta todas as bolas de Bola1 a Bola15
    colunas_bolas = [f'Bola{i}' for i in range(1, 16)]
    # Verifica se as colunas existem antes de tentar coletar
    colunas_existentes = [col for col in colunas_bolas if col in df_sorteios.columns]

    if not colunas_existentes:
        st.warning(f"N√£o foram encontradas colunas de bolas (Bola1-Bola15) no DataFrame de {tipo_estatistica}.")
        return pd.DataFrame({'N√∫mero': [], 'Frequ√™ncia': []})

    todos_numeros_sorteados = df_sorteios[colunas_existentes].values.flatten().tolist()

    frequencia = collections.Counter(todos_numeros_sorteados)
    df_frequencia = pd.DataFrame(frequencia.items(), columns=['N√∫mero', 'Frequ√™ncia'])
    df_frequencia = df_frequencia.sort_values(by='Frequ√™ncia', ascending=False)
    return df_frequencia

def calcular_estatisticas_simuladas():
    """Calcula a frequ√™ncia de cada n√∫mero nos sorteios simulados."""
    todos_numeros_simulados = []
    for registro in st.session_state.historico_sorteios_simulados:
        todos_numeros_simulados.extend(registro['sorteio'])

    if not todos_numeros_simulados:
        return pd.DataFrame({'N√∫mero': [], 'Frequ√™ncia': []})

    frequencia = collections.Counter(todos_numeros_simulados)
    df_frequencia = pd.DataFrame(frequencia.items(), columns=['N√∫mero', 'Frequ√™ncia'])
    df_frequencia = df_frequencia.sort_values(by='Frequ√™ncia', ascending=False)
    return df_frequencia

# --- LAYOUT DA APLICA√á√ÉO STREAMLIT ---

# Cria√ß√£o de abas (tabs) para organizar o conte√∫do
tab1, tab2, tab3, tab4 = st.tabs(["Simulador", "Estat√≠sticas Oficiais", "Inserir Concurso Oficial", "Tabela de Pre√ßos"])

# --- ABA 1: Simulador ---
with tab1:
    st.header("Gerar Novo Sorteio Simulado")
    if st.button("Sortear N√∫meros"):
        novo_sorteio_simulado = gerar_sorteio_lotofacil()
        adicionar_sorteio_simulado_ao_historico(novo_sorteio_simulado)
        st.success(f"Seu sorteio atual: **{', '.join(map(str, novo_sorteio_simulado))}**")

    # Hist√≥rico de Sorteios Simulados
    if st.session_state.historico_sorteios_simulados:
        st.header("Hist√≥rico de Sorteios Simulados")

        total_sorteios_simulados = len(st.session_state.historico_sorteios_simulados)

        # Ajuste para o slider: s√≥ aparece se houver mais de um sorteio
        if total_sorteios_simulados > 1:
            initial_slider_value_simulado = min(10, total_sorteios_simulados)
            num_sorteios_para_mostrar_simulados = st.slider(
                "Mostrar √∫ltimos X sorteios simulados:",
                min_value=1,
                max_value=total_sorteios_simulados,
                value=initial_slider_value_simulado,
                key="slider_simulados" # Chave √∫nica para o slider
            )
        else:
            num_sorteios_para_mostrar_simulados = 1

        st.write(f"√öltimos {num_sorteios_para_mostrar_simulados} sorteios registrados:")
        for i, registro in enumerate(reversed(st.session_state.historico_sorteios_simulados[-num_sorteios_para_mostrar_simulados:])):
            st.markdown(f"**Sorteio {total_sorteios_simulados - i} em {registro['data']}:** {', '.join(map(str, registro['sorteio']))}")

        if st.button("Limpar Hist√≥rico de Simulados"):
            st.session_state.historico_sorteios_simulados = []
            st.session_state.ultimo_sorteio_gerado_simulado = None
            st.success("Hist√≥rico de sorteios simulados limpo!")
            st.rerun()
    else:
        st.info("O hist√≥rico de sorteios simulados come√ßar√° a ser registrado a partir do segundo sorteio. Gere seu primeiro sorteio!")

    st.header("Estat√≠stica 1: Seus Sorteios Simulados")
    df_estatisticas_simuladas = calcular_estatisticas_simuladas()

    if not df_estatisticas_simuladas.empty:
        st.write("Frequ√™ncia de cada n√∫mero nos seus sorteios simulados:")
        st.dataframe(df_estatisticas_simuladas, use_container_width=True)
        st.subheader("Gr√°fico de Frequ√™ncia de Simulados")
        st.bar_chart(df_estatisticas_simuladas.set_index('N√∫mero'))
        st.info(f"Total de sorteios simulados hist√≥ricos: {len(st.session_state.historico_sorteios_simulados)}")
    else:
        st.info("Gere alguns sorteios simulados para ver as estat√≠sticas.")

# --- ABA 2: Estat√≠sticas Oficiais ---
with tab2:
    st.header("Estat√≠stica 2: N√∫meros Oficiais da Caixa")
    df_oficial = get_dados_oficiais_cached() # Carrega os dados oficiais (usando cache)

    if not df_oficial.empty:
        st.subheader("Hist√≥rico Completo de Sorteios Oficiais")
        st.dataframe(df_oficial, use_container_width=True)

        st.subheader("Frequ√™ncia dos N√∫meros Oficiais")
        df_estatisticas_oficiais = calcular_estatisticas_geral(df_oficial, "oficiais")

        if not df_estatisticas_oficiais.empty:
            st.write("Frequ√™ncia de cada n√∫mero nos sorteios oficiais:")
            st.dataframe(df_estatisticas_oficiais, use_container_width=True)
            st.subheader("Gr√°fico de Frequ√™ncia de Oficiais")
            st.bar_chart(df_estatisticas_oficiais.set_index('N√∫mero'))
            st.info(f"Total de concursos oficiais carregados: {len(df_oficial)}")
        else:
            st.warning("N√£o foi poss√≠vel calcular as estat√≠sticas dos n√∫meros oficiais. Verifique a estrutura do arquivo.")
    else:
        st.warning(f"Arquivo '{ARQUIVO_HISTORICO_OFICIAL}' n√£o encontrado ou vazio. Por favor, adicione um arquivo CSV com o hist√≥rico de sorteios oficiais ou insira novos concursos.")

# --- ABA 3: Inserir Concurso Oficial ---
with tab3:
    st.header("Adicionar Novo Concurso Oficial da Caixa")
    st.write("Preencha os campos abaixo para adicionar um novo resultado de concurso oficial.")

    with st.form("form_novo_concurso"):
        col1, col2 = st.columns(2)
        with col1:
            concurso = st.number_input("N√∫mero do Concurso", min_value=1, step=1, key="concurso_input")
        with col2:
            data_sorteio = st.date_input("Data do Sorteio", datetime.now(), key="data_sorteio_input")

        st.subheader("Bolas Sorteadas (1 a 25)")
        bolas = []
        cols_bolas = st.columns(5) # 3 colunas para input das bolas
        for i in range(1, 16):
            # Usar key para evitar StaleStateError
            bola_val = cols_bolas[(i-1) % 5].number_input(
                f"Bola {i}",
                min_value=1,
                max_value=25,
                step=1,
                key=f"bola_{i}_input"
            )
            bolas.append(bola_val)

        submitted = st.form_submit_button("Adicionar Concurso")

        if submitted:
            # Validar se os 15 n√∫meros s√£o √∫nicos e v√°lidos
            if len(set(bolas)) != 15:
                st.error("Por favor, insira 15 n√∫meros √∫nicos para as bolas sorteadas.")
            elif any(not (1 <= b <= 25) for b in bolas):
                st.error("As bolas devem ser n√∫meros entre 1 e 25.")
            else:
                # Criar um DataFrame para o novo sorteio
                novo_sorteio_dict = {
                    'Concurso': int(concurso),
                    'Data Sorteio': data_sorteio.strftime("%Y-%m-%d") # Formato YYYY-MM-DD
                }
                for i, bola in enumerate(bolas):
                    novo_sorteio_dict[f'Bola{i+1}'] = bola

                novo_df = pd.DataFrame([novo_sorteio_dict])

                try:
                    salvar_novo_sorteio_oficial(novo_df)
                    st.success("Concurso adicionado com sucesso e salvo!")
                    # Limpar os campos do formul√°rio (opcional, requer resetar chaves)
                    # Para limpar, voc√™ teria que redefinir o estado das chaves dos inputs,
                    # o que geralmente √© feito com um st.rerun() ap√≥s a submiss√£o,
                    # mas o rerunning j√° est√° no salvar_novo_sorteio_oficial.
                except Exception as e:
                    st.error(f"Erro ao salvar o concurso: {e}")

# --- ABA 4: Tabela de Pre√ßos ---
with tab4:
    st.header("Tabela de Pre√ßos da Lotof√°cil")
    df_precos = get_tabela_precos_cached()

    if not df_precos.empty:
        st.dataframe(df_precos, use_container_width=True)
    else:
        st.warning(f"Arquivo '{ARQUIVO_TABELA_PRECO}' n√£o encontrado ou vazio. Por favor, adicione um arquivo CSV com a tabela de pre√ßos.")

st.markdown("---")
st.markdown("Desenvolvido com ‚ù§Ô∏è por [Marcia Romanato]")